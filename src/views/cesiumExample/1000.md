<!--

:::details 展开代码

```vue

```

::: -->

<!-- <video controls width="600">
  <source src="../../Aassets/Practice/沿线标注.mp4" type="video/mp4" />
  您的浏览器不支持HTML5视频标签。
</video> -->


<!-- 接下来计划 -->

#### 封装 hooks

1. 事件
2. 交互工具
3. 材质封装
4. 时钟

#### 案例

- 视锥体
- 碰撞检测
- 聚合
- 实体悬浮高亮
- 热力图

```js
// 实体悬停效果实现
let highlightedEntity = null;
viewer.screenSpaceEventHandler.setInputAction((movement) => {
  const picked = viewer.scene.pick(movement.endPosition);

  // 清除上一个高亮实体
  if (highlightedEntity && (!picked || picked.id !== highlightedEntity)) {
    highlightedEntity.polygon.material = Cesium.Color.RED.withAlpha(0.5);
    highlightedEntity = null;
  }

  // 高亮当前实体
  if (picked && picked.id instanceof Cesium.Entity) {
    highlightedEntity = picked.id;
    highlightedEntity.polygon.material = Cesium.Color.YELLOW.withAlpha(0.7);
  }
}, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
```

- 动态闪烁

heightReference 不能设置为 CLAMP_TO_GROUND 贴地显示

```js
const pointEntity = viewer.entities.add({
  position: Cesium.Cartesian3.fromDegrees(116.3975, 39.9075, 50),
  point: {
    color: Cesium.Color.RED.withAlpha(0.8), // 80% 不透明的红色
    pixelSize: 20, // 直径20像素
    outlineColor: Cesium.Color.WHITE, // 白色轮廓
    outlineWidth: 3, // 轮廓宽度3像素
    show: true, // 默认显示
  },
});
// 使用时间动态颜色实现闪烁
pointEntity.point.color = new Cesium.CallbackProperty(() => {
  const alpha = 0.5 + 0.5 * Math.sin(Date.now() / 500);
  return Cesium.Color.RED.withAlpha(alpha);
}, false);
```

- 将相机限制在某个区域（下面代码存在问题）

```js
// 限制相机在北京市范围内
const beijingBounds = Cesium.Rectangle.fromDegrees(115.7, 39.4, 117.4, 41.0);

viewer.camera.changed.addEventListener(() => {
  const cartographic = Cesium.Cartographic.fromCartesian(
    viewer.camera.position
  );

  // 检查是否超出边界
  if (!Cesium.Rectangle.contains(beijingBounds, cartographic)) {
    // 计算边界内最近点
    const clamped = Cesium.Rectangle.clamp(beijingBounds, cartographic);
    viewer.camera.position = Cesium.Cartesian3.fromRadians(
      clamped.longitude,
      clamped.latitude,
      clamped.height
    );
  }
});
```

- 绘制

- 实体拖拽交互

- 动态纹理材质

```javascript
entity.polygon.material = new Cesium.ImageMaterialProperty({
  image: "/textures/water.jpg",
  transparent: true,
  // 动态纹理偏移（实现流动效果）
  repeat: new Cesium.Cartesian2(2, 2),
  offset: new Cesium.CallbackProperty(() => {
    return new Cesium.Cartesian2(viewer.clock.currentTime.secondsOfDay / 10, 0);
  }, false),
});
```

- 粒子系统材质

```javascript
// 创建粒子系统
const particleSystem = new Cesium.ParticleSystem({
  image: "/textures/particle.png",
  startColor: Cesium.Color.RED.withAlpha(0.8),
  endColor: Cesium.Color.YELLOW.withAlpha(0.0),
  startScale: 1.0,
  endScale: 4.0,
  particleLife: 2.0,
  speed: 5.0,
  emissionRate: 10,
  width: 50,
  height: 50,
  lifeTime: 16.0,
});

// 应用为实体材质
entity.point.material = new Cesium.ParticleSystemMaterialProperty(
  particleSystem
);
```

- 通过父子关系构建实体层级结构

```js
// 创建父实体
const parentEntity = viewer.entities.add({
  position: Cesium.Cartesian3.fromDegrees(116.3975, 39.9075),
  name: "校园",
});

// 创建子实体
const buildingEntity = viewer.entities.add({
  parent: parentEntity, // 设置父实体
  position: new Cesium.Cartesian3(100, 50, 0), // 相对父实体的局部坐标
  box: {
    dimensions: new Cesium.Cartesian3(80, 40, 60),
    material: Cesium.Color.GRAY,
  },
});

const roadEntity = viewer.entities.add({
  parent: parentEntity,
  polyline: {
    positions: [
      new Cesium.Cartesian3(-200, -100, 0),
      new Cesium.Cartesian3(200, 100, 0),
    ],
    width: 10,
    material: Cesium.Color.WHITE,
  },
});

// 操作父实体影响所有子实体
parentEntity.position = Cesium.Cartesian3.fromDegrees(116.4075, 39.9175);
```


<!-- transform 粒子系统  -->

# 常用实例

## CallbackProperty

`CallbackProperty`是一种用于动态计算实体（Entity）属性的机制。它允许你通过回调函数在每一帧中动态计算属性的值，从而实现动画、随时间变化的属性等效果。

### 语法

```js
new Cesium.CallbackProperty(callback, isConstant);
```

- callback: 计算属性值的函数，接收 (time, result) 参数
- isConstant: 如果为 true，只计算一次（静态）；为 false 则每帧计算（动态）

#### 示例一：动态圆周运动

:::details 点击查看代码

```js
// 创建沿圆周运动的点
const startTime = Cesium.JulianDate.now();
const position = new Cesium.CallbackProperty((time, result) => {
  // 计算经过的时间（秒）
  const elapsed = Cesium.JulianDate.secondsDifference(time, startTime);

  // 计算位置（圆周运动）
  const radius = 100000; // 半径100公里
  const angle = (elapsed * Math.PI) / 10; // 每10秒转180度

  return Cesium.Cartesian3.fromDegrees(
    116.39 + (radius * Math.cos(angle)) / 111000, // 经度
    39.9 + (radius * Math.sin(angle)) / 111000, // 纬度
    5000 // 高度
  );
}, false); // false 表示动态变化

const point = viewer.entities.add({
  position: position,
  point: {
    pixelSize: 20,
    color: Cesium.Color.RED,
  },
});
viewer.clock.shouldAnimate = true; // 确保时钟动画开启
viewer.trackedEntity = point; // 使相机跟随点移动
```

:::

#### 示例二：动态闪烁点

:::details 点击查看代码

```js
const pointEntity = viewer.entities.add({
  position: Cesium.Cartesian3.fromDegrees(116.3975, 39.9075, 50),
  point: {
    color: Cesium.Color.RED.withAlpha(0.8), // 80% 不透明的红色
    pixelSize: 20, // 直径20像素
    outlineColor: Cesium.Color.WHITE, // 白色轮廓
    outlineWidth: 3, // 轮廓宽度3像素
    show: true, // 默认显示
    // heightReference:Cesium.HeightReference.CLAMP_TO_GROUND,
  },
});
// 使用时间动态颜色实现闪烁
pointEntity.point.color = new Cesium.CallbackProperty((time) => {
  const alpha = 0.5 + 0.5 * Math.sin(Date.now() / 500);
  return Cesium.Color.RED.withAlpha(alpha);
}, false);

viewer.camera.setView({
  destination: Cesium.Cartesian3.fromDegrees(116.3975, 39.9075, 500),
  orientation: {
    heading: Cesium.Math.toRadians(0),
    pitch: Cesium.Math.toRadians(-90),
    roll: Cesium.Math.toRadians(0),
  },
});
```

:::


#### 性能优化

- 数据分块加载，当处理成千上万的实体时，需要采用特殊策略优化性能

```javascript
// 实现数据分块加载
class EntityChunkLoader {
  constructor(viewer, chunkSize = 1000) {
    this.viewer = viewer;
    this.chunkSize = chunkSize;
    this.loadedChunks = new Set();
    this.dataSource = new Cesium.CustomDataSource("chunkedData");
    viewer.dataSources.add(this.dataSource);

    // 监听相机移动，动态加载数据块
    viewer.camera.moveEnd.addEventListener(() => this.loadVisibleChunks());
  }

  // 加载可见区域的数据块
  loadVisibleChunks() {
    const viewRectangle = viewer.camera.computeViewRectangle();
    const chunks = this.getChunksInView(viewRectangle);

    chunks.forEach((chunkId) => {
      if (!this.loadedChunks.has(chunkId)) {
        this.loadChunk(chunkId);
        this.loadedChunks.add(chunkId);
      }
    });
  }

  // 加载单个数据块
  async loadChunk(chunkId) {
    const entities = await fetchEntitiesFromServer(chunkId);
    this.dataSource.entities.addMany(entities);
  }
}

// 使用分块加载器
const chunkLoader = new EntityChunkLoader(viewer);
chunkLoader.loadVisibleChunks();
```

- 对于大量相同类型的实体，使用`Primitive`配合`GeometryInstance`实现批处理渲染：

```javascript
// 创建实例化几何体
const instances = [];
for (let i = 0; i < 10000; i++) {
  // 随机位置
  const lon = 116.3975 + (Math.random() - 0.5) * 0.2;
  const lat = 39.9075 + (Math.random() - 0.5) * 0.2;

  instances.push(
    new Cesium.GeometryInstance({
      geometry: new Cesium.BoxGeometry({
        vertexFormat: Cesium.PerInstanceColorAppearance.VERTEX_FORMAT,
        dimensions: new Cesium.Cartesian3(5, 5, 10),
      }),
      modelMatrix: Cesium.Transforms.eastNorthUpToFixedFrame(
        Cesium.Cartesian3.fromDegrees(lon, lat)
      ),
      attributes: {
        color: Cesium.ColorGeometryInstanceAttribute.fromColor(
          Cesium.Color.fromRandom({ alpha: 0.7 })
        ),
      },
      id: `building-${i}`,
    })
  );
}

// 添加到场景
viewer.scene.primitives.add(
  new Cesium.Primitive({
    geometryInstances: instances,
    appearance: new Cesium.PerInstanceColorAppearance({
      translucent: true,
      closed: true,
    }),
    asynchronous: true, // 异步加载
  })
);
```

#### LOD（细节层次）控制

为不同距离范围提供不同精度的实体表示：

```javascript
// 实现LOD实体
function createLodEntity(viewer) {
  const entity = viewer.entities.add({
    position: Cesium.Cartesian3.fromDegrees(116.3975, 39.9075, 100),
    // 根据距离切换不同几何表示
    billboard: new Cesium.CallbackProperty(() => {
      const distance = Cesium.Cartesian3.distance(
        viewer.camera.position,
        entity.position.getValue(viewer.clock.currentTime)
      );

      if (distance > 5000) {
        return { image: "/icons/low_detail.png", scale: 0.8 };
      } else if (distance > 2000) {
        return { image: "/icons/medium_detail.png", scale: 1.0 };
      }
      return { image: "/icons/high_detail.png", scale: 1.2 };
    }, false),
    // 近距离显示详细模型
    model: new Cesium.CallbackProperty(() => {
      const distance = Cesium.Cartesian3.distance(
        viewer.camera.position,
        entity.position.getValue(viewer.clock.currentTime)
      );

      return distance < 1000
        ? {
            uri: "/models/detail_model.glb",
            scale: 0.5,
          }
        : undefined; // 距离远时不显示模型
    }, false),
  });
  return entity;
}
```

### 6.2 交互式编辑系统

实现实体的创建和编辑功能：

```javascript
class EntityEditor {
  constructor(viewer) {
    this.viewer = viewer;
    this.handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
    this.isEditing = false;
    this.currentEntity = null;
    this.points = [];
    this.setupEvents();
  }

  // 设置事件监听
  setupEvents() {
    // 左键点击添加点
    this.handler.setInputAction((movement) => {
      if (!this.isEditing) return;

      const position = this.getClickPosition(movement.position);
      if (position) {
        this.points.push(position);
        this.updateCurrentEntity();
      }
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    // 右键完成编辑
    this.handler.setInputAction(() => {
      if (this.isEditing && this.currentEntity) {
        this.isEditing = false;
        this.finalizeEntity();
      }
    }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

    // 鼠标移动更新临时实体
    this.handler.setInputAction((movement) => {
      if (this.isEditing && this.points.length > 0) {
        const position = this.getClickPosition(movement.position);
        if (position) {
          const tempPoints = [...this.points, position];
          this.updateTemporaryEntity(tempPoints);
        }
      }
    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
  }

  // 获取点击位置
  getClickPosition(screenPosition) {
    const ray = this.viewer.camera.getPickRay(screenPosition);
    return this.viewer.scene.globe.pick(ray, this.viewer.scene);
  }

  // 开始创建实体
  startCreate(type) {
    this.isEditing = true;
    this.type = type;
    this.points = [];
    this.currentEntity = null;
    this.tempEntity = null;
  }

  // 更新当前实体
  updateCurrentEntity() {
    if (!this.currentEntity) {
      this.currentEntity = this.viewer.entities.add({
        [this.getTypeProperty()]: this.getGeometryProperty(this.points),
      });
    } else {
      this.currentEntity[this.getTypeProperty()] = this.getGeometryProperty(
        this.points
      );
    }
  }

  // 更新临时实体
  updateTemporaryEntity(points) {
    if (!this.tempEntity) {
      this.tempEntity = this.viewer.entities.add({
        [this.getTypeProperty()]: this.getGeometryProperty(points, true),
      });
    } else {
      this.tempEntity[this.getTypeProperty()] = this.getGeometryProperty(
        points,
        true
      );
    }
  }

  // 完成实体创建
  finalizeEntity() {
    // 移除临时实体
    if (this.tempEntity) {
      this.viewer.entities.remove(this.tempEntity);
      this.tempEntity = null;
    }

    // 添加实体到集合
    this.viewer.entities.add(this.currentEntity);

    // 触发创建完成事件
    this.onEntityCreated(this.currentEntity);
  }

  // 获取几何属性
  getGeometryProperty(points, isTemp = false) {
    const properties = {
      polyline: {
        positions: points,
        width: isTemp ? 2 : 3,
        material: isTemp ? Cesium.Color.YELLOW : Cesium.Color.BLUE,
      },
      polygon: {
        hierarchy: points,
        material: isTemp
          ? Cesium.Color.YELLOW.withAlpha(0.3)
          : Cesium.Color.BLUE.withAlpha(0.5),
        outline: true,
        outlineColor: Cesium.Color.BLACK,
      },
    };
    return properties[this.type];
  }

  // 获取类型属性名
  getTypeProperty() {
    return this.type === "polyline" ? "polyline" : "polygon";
  }

  // 创建完成回调
  onEntityCreated(entity) {
    console.log("实体创建完成:", entity);
  }
}

// 使用编辑器
const editor = new EntityEditor(viewer);
// 开始创建多边形
editor.startCreate("polygon");
```


  <!-- // 它在平铺方案中的每个渲染图块周围绘制一个框，并在其中绘制一个标签，指示图块的 X、Y、Level 坐标。这对于调试地形和图像渲染问题非常有用
  const imageryProvider = new Cesium.TileCoordinatesImageryProvider({
    color: Cesium.Color.RED,
  });
  viewer.imageryLayers.addImageryProvider(imageryProvider); -->




## 主线 (60%-70%精力)：Cesium/OpenLayers 深度案例系列

### 主题化： 不要零散地写，而是做成系列。例如：

#### 《Cesium气象可视化系列》：台风路径、降雨量、云层效果。

#### 《Cesium地下管线可视化系列》：模型加载、剖切分析、爆管分析。

#### 《OpenLayers自定义交互系列》：绘制、测量、拖拽、动画。

